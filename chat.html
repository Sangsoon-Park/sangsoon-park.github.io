<!-- chat.fallback.html -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPT와 대화하기 (폴백 페이지)</title>
  <style>
    :root { font-family: system-ui, sans-serif; line-height: 1.4; }
    body { margin: 0; background:#0b0c10; color:#eef1f5; }
    header { padding: 16px 24px; border-bottom: 1px solid #1f2330; }
    main { max-width: 820px; margin: 0 auto; padding: 24px; }
    .bar { display:flex; gap:10px; }
    input[type="text"] { flex: 1; padding: 12px; border-radius: 8px; border: 1px solid #2a3042; background:#111420; color:#eef1f5; }
    button { padding: 12px 16px; border-radius: 8px; border: 0; background:#5562ea; color:#fff; cursor:pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .msg { padding: 12px 14px; border-radius: 10px; margin: 12px 0; white-space: pre-wrap; }
    .user { background:#1a2033; }
    .assistant { background:#111826; }
    .sys { font-size: 12px; color: #a9b1c4; margin-bottom: 6px; }
    .meta { font-size: 12px; color: #9aa3b2; margin-top: 4px; }
  </style>
</head>
<body>
  <header>
    <div><strong>GPT와 대화하기</strong> <span class="meta">— 스트리밍 폴백 데모</span></div>
  </header>
  <main>
    <div class="sys">※ 이 페이지는 `/api/chat`(POST)로 요청합니다. GET 호출 시 <em>Method Not Allowed</em>가 뜨는 것이 정상이에요.</div>

    <div id="log"></div>

    <form id="f" class="bar">
      <input id="q" type="text" placeholder="메시지를 입력하세요…" autocomplete="off" />
      <button id="send" type="submit">보내기</button>
    </form>

    <div class="meta" style="margin-top:12px">
      모델: <code id="modelLabel">gpt-4o-mini</code> · 스트리밍: <code>true</code>
    </div>
  </main>

  <script>
    const form = document.getElementById('f');
    const input = document.getElementById('q');
    const log = document.getElementById('log');
    const btn = document.getElementById('send');

    let model = 'gpt-4o-mini'; // 서버 기본과 맞춰둠
    document.getElementById('modelLabel').textContent = model;

    function addBubble(text, who) {
      const div = document.createElement('div');
      div.className = `msg ${who}`;
      div.textContent = text;
      log.appendChild(div);
      div.scrollIntoView({ behavior: 'smooth', block: 'end' });
      return div;
    }

    function appendText(div, text) {
      div.textContent += text;
    }

    async function streamChat(userText) {
      // 사용자가 입력한 메시지 출력
      addBubble(userText, 'user');

      // 어시스턴트 말풍선(스트리밍으로 채워짐)
      const aDiv = addBubble('', 'assistant');

      btn.disabled = true; input.disabled = true;

      const body = {
        model,
        stream: true,
        messages: [{ role: 'user', content: userText }]
      };

      let resp;
      try {
        resp = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      } catch (e) {
        appendText(aDiv, `요청 실패: ${e.message}`);
        btn.disabled = false; input.disabled = false;
        return;
      }

      if (!resp.ok) {
        const text = await resp.text().catch(()=>'');
        appendText(aDiv, `서버 오류 ${resp.status}: ${text || '응답 본문 없음'}`);
        btn.disabled = false; input.disabled = false;
        return;
      }

      // OpenAI Chat Completions의 SSE를 파싱
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          // SSE는 빈 줄(\n\n)로 이벤트 구분
          const parts = buffer.split('\n\n');
          buffer = parts.pop() || '';

          for (const part of parts) {
            const lines = part.split('\n').map(l => l.trim());
            const dataLine = lines.find(l => l.startsWith('data:'));
            if (!dataLine) continue;

            const data = dataLine.slice(5).trim();
            if (data === '[DONE]') {
              break;
            }

            try {
              const json = JSON.parse(data);
              const delta = json?.choices?.[0]?.delta;
              if (delta?.content) {
                appendText(aDiv, delta.content);
              }
            } catch (err) {
              // 파싱 실패는 건너뜀 (하트비트 등)
            }
          }
        }
      } catch (err) {
        appendText(aDiv, `\n(스트리밍 중단: ${err.message})`);
      } finally {
        btn.disabled = false; input.disabled = false;
        input.focus();
      }
    }

    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      streamChat(text);
    });
  </script>
</body>
</html>