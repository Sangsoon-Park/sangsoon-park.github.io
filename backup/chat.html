<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPT와 대화하기</title>
  <style>
    :root { font-family: system-ui, sans-serif; line-height: 1.4; }
    body { margin: 0; background:#0b0c10; color:#eef1f5; }
    header { padding: 16px 24px; border-bottom: 1px solid #1f2330; }
    main { max-width: 820px; margin: 0 auto; padding: 24px; }
    .bar { display:flex; gap:10px; }
    input[type="text"] { flex: 1; padding: 12px; border-radius: 8px; border: 1px solid #2a3042; background:#111420; color:#eef1f5; }
    button { padding: 12px 16px; border-radius: 8px; border: 0; background:#5562ea; color:#fff; cursor:pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .msg { padding: 12px 14px; border-radius: 10px; margin: 12px 0; white-space: pre-wrap; }
    .user { background:#1a2033; }
    .assistant { background:#111826; }
    .sys { font-size: 12px; color: #a9b1c4; margin-bottom: 6px; }
    .meta { font-size: 12px; color: #9aa3b2; margin-top: 4px; }
    .err { color:#ffb4b4 }
  </style>
</head>
<body>
  <header>
    <div><strong>GPT와 대화하기</strong> </div>
  </header>
  <main>
    <div class="sys">
      ※ 이 페이지는 <code>/api/chat</code>으로 <b>POST</b> 요청을 보냅니다.
      (브라우저로 <code>/api/chat</code>을 직접 열면 GET 405가 뜨는 게 정상입니다.)
    </div>

    <div id="log"></div>

    <form id="f" class="bar">
      <input id="q" type="text" placeholder="메시지를 입력하세요…" autocomplete="off" />
      <button id="send" type="submit">보내기</button>
    </form>

    <div class="meta" style="margin-top:12px">
      모델: <code id="modelLabel">gpt-4o-mini</code> · 스트리밍: <code>true</code> · 엔드포인트: <code id="ep"></code>
    </div>
  </main>

  <script>
    // ★ 절대경로 사용: 로컬 파일로 열어도 Vercel API로 직접 POST합니다.
    const ENDPOINT = 'https://my-chat-five-kappa.vercel.app/api/chat';

    const form = document.getElementById('f');
    const input = document.getElementById('q');
    const log = document.getElementById('log');
    const btn = document.getElementById('send');

    const model = 'gpt-4o-mini';
    document.getElementById('modelLabel').textContent = model;
    document.getElementById('ep').textContent = ENDPOINT;

    function addBubble(text, who) {
      const div = document.createElement('div');
      div.className = `msg ${who}`;
      div.textContent = text;
      log.appendChild(div);
      div.scrollIntoView({ behavior: 'smooth', block: 'end' });
      return div;
    }
    function appendText(div, text) { div.textContent += text; }

    // SSE 블록 파서 (Responses API & Chat Completions 둘 다 처리)
    function handleSSEChunk(part, aDiv) {
      const lines = part.split('\n').map(l => l.trim());
      const dataLines = lines.filter(l => l.startsWith('data:'));
      for (const dl of dataLines) {
        const data = dl.slice(5).trim();
        if (!data) continue;
        if (data === '[DONE]') return { done: true }; // chat/completions 종료 신호
        try {
          const json = JSON.parse(data);

          // Responses API
          if (json.type) {
            if (json.type === 'response.output_text.delta' && typeof json.delta === 'string') {
              appendText(aDiv, json.delta);
            } else if (json.type === 'response.completed' || json.type === 'response.output_text.done') {
              return { done: true };
            }
            continue;
          }

          // Chat Completions
          const delta = json?.choices?.[0]?.delta;
          if (delta?.content) appendText(aDiv, delta.content);
        } catch (_) { /* JSON이 아니면 무시 */ }
      }
      return { done: false };
    }

    async function streamChat(userText) {
      addBubble(userText, 'user');
      const aDiv = addBubble('', 'assistant');

      btn.disabled = true; input.disabled = true;

      const body = {
        model,
        stream: true,
        messages: [{ role: 'user', content: userText }]
      };

      let resp;
      try {
        resp = await fetch(ENDPOINT, {
          method: 'POST',
          mode: 'cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      } catch (e) {
        aDiv.classList.add('err');
        appendText(aDiv, `요청 실패: ${e.message}`);
        btn.disabled = false; input.disabled = false; input.focus();
        return;
      }

      if (!resp.ok) {
        const text = await resp.text().catch(()=> '');
        aDiv.classList.add('err');
        appendText(aDiv, `서버 오류 ${resp.status}: ${text || '응답 본문 없음'}\n(※ 브라우저가 GET으로 보내면 405가 납니다. 이 화면은 POST로 전송합니다.)`);
        btn.disabled = false; input.disabled = false; input.focus();
        return;
      }

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '', stop = false;

      try {
        while (!stop) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          // SSE는 빈 줄(\n\n)로 이벤트 구분
          const parts = buffer.split('\n\n');
          buffer = parts.pop() || '';
          for (const part of parts) {
            const { done: partDone } = handleSSEChunk(part, aDiv);
            if (partDone) { stop = true; break; }
          }
        }
      } catch (err) {
        aDiv.classList.add('err');
        appendText(aDiv, `\n(스트리밍 중단: ${err.message})`);
      } finally {
        btn.disabled = false; input.disabled = false; input.focus();
      }
    }

    // 폼 기본 GET 전송 방지 + POST로 호출
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      streamChat(text);
    });
  </script>
</body>
</html>
